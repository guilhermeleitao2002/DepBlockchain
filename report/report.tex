% This is samplepaper.tex, a sample chapter demonstrating the LLNCS macro
% package for Springer Computer Science proceedings; Version 2.21 of 2022/01/12
%
\documentclass[runningheads]{llncs}
%
\usepackage[T1]{fontenc}
% T1 fonts will be used to generate the final print and online PDFs, so please
% use T1 fonts in your manuscript whenever possible. Other font encondings may
% result in incorrect characters.
%
\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should be
% included in EPS format.
%
% If you use the hyperref package, please uncomment the following two lines to
% display URLs in blue roman font according to Springer's eBook style:
% \usepackage{color} \renewcommand\UrlFont{\color{blue}\rmfamily} \urlstyle{rm}
%
\begin{document}
%
\title{DepChain - Stage 1}
%
%\titlerunning{Abbreviated paper title} If the paper title is too long for the
% running head, you can set an abbreviated paper title here
%
\author{Simão de Melo Rocha Frias Sanguinho\inst{1}\orcidID{102082} \and José
Augusto Alves Pereira\inst{1}\orcidID{103252} \and Guilherme Silvério de
Carvalho Romeiro Leitão\inst{1}\orcidID{99951}}
%
\authorrunning{S. Sanguinho, J. Pereira, G. Leitão.}
% First names are abbreviated in the running head. If there are more than two
% authors, 'et al.' is used.
%
\institute{Instituto Superior Técnico, Lisboa, Portugal}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
This project aims to develop a simplified permissioned block-chain system, named
Dependable Chain (DepChain), with high dependability guarantees. The system is
designed to be built iteratively, with the first stage focusing on the
communication and consensus layer of a simple blockchain implementation, and the
development of a client and a library that can interact with the blockchain
system. The project leverages the Byzantine Read/Write Epoch Consensus
algorithm, with simplifying assumptions such as static system membership, a
predefined leader process, and a Public Key Infrastructure (PKI). For message
communication, the implementation will use authenticated perfect links, with the
assumption that the  network  is  unreliable:  it  can  drop,  delay, duplicate,
or  corrupt messages, and communication channels are not secured. The
implementation is structured in Java, utilizing the Java Crypto API for
cryptographic functions, and is designed to handle malicious behavior from a
subset of blockchain members while ensuring safety and liveness under the
assumption of a correct leader. The final submission for stage 1 includes a
self-contained zip archive with the source code, demo tests, and a concise
report detailing the design, threats, and dependability guarantees of the
system.
%
\keywords{Blockchain \and Byzantine Fault Tolerance \and Consensus Algorithm \and Dependability \and Java Implementation}
\end{abstract}
%
\section{Introduction}
This report presents the design and implementation of a Byzantine Fault Tolerant
(BFT) blockchain service, designed to withstand malicious behavior from a subset
of blockchain members and operate reliably in an unstable network environment.
The system is resilient to arbitrary (Byzantine) behavior from faulty nodes and
can handle unreliable network conditions, including message drops, delays,
duplication, and corruption, without relying on secure communication channels.
To achieve consensus in such adversarial conditions, the project uses the
Byzantine Read / Write Epoch Consensus algorithm, as described in the course
book [1] (Algorithms 5.17 and 5.18). The report outlines the system
architecture, which includes the network, client, library, blockchain, and
consensus layers. It also describes how the system addresses various Byzantine
attack scenarios, ensuring safety and liveness under the assumption of a correct
leader. Finally, the report concludes with key findings, lessons learned, and
potential areas for future improvement.
%
\section{Architecture}
\subsection{Network Layer}
The network layer is responsible for managing the communication any two
processes (members or clients) in the system. By replicating Authenticated
Perfect Links, the network layer ensures that messages are guaranteed to be
eventually delivered to the intended recipient, with it's integrity and
authenticity preserved. There are three main components in the network layer: 

- Message, which encapsulates the message content and metadata. It contains the
type field to identify the message type (e.g., READ, STATE, ACK, etc.). It's
also this component that will be signed by the sender and verified by the
receiver. 

- PerfectLink, which implements the core communication logics, including
sending, receiving and managing sessions (explained next). To simulate the
unreliable network, we use UDP sockets. 

- Session, which represents a communication session between two processes. The
session contains information like the destination process ID, address, session
key, and counters for tracking sent and acknowledged messages. The session key
is a symmetric key that is used for encrypting and signing messages (because using the public key for
every message would be too expensive).
\subsubsection{Session Establishment}

Before any communication can occur, a session must be established between two
processes. The session establishment process is as follows: A process initiates
a session by sending a STARTSESSION message. Then, the recipient responds with a
ACKSESSION message, containing an symmetric session key that is encrypted using the recipient's public key (thus ensuring confidentiality). Once the session is
established, all subsequent messages are signed and verified using the session
key to ensure authenticity and integrity.
%
\subsection{Client and Library Layer}
The system's regular workflow would work as it follows: an user will issue the append <message> command via the client's CLI. The client
layer will delegate the request to the library layer. Then, the library will
construct a CLIENTREQUEST message and sends it to the leader process (known
beforehand) using PerfectLink. Next, the library will wait for CLIENTREPLY from
1 processes. Since we assume a non-byzantine leader, the client does not need to 
wait for F+1 replies.

%
\subsection{Blockchain Layer}
The blockchain layer represents a node in the permissioned (closed membership)
blockchain network. Each member is responsible for participating in the
consensus protocol, maintaining a local copy of the blockchain.The system is
designed to ensure that all members agree on the state of the blockchain, even
in the presence of faulty nodes, by leveraging a Byzantine fault-tolerant
consensus protocol (Byzantine Read/Write Epoch Consensus). The blockchain member
maintains an in-memory representation of the blockchain, implemented as a list of string objects.
It also keeps a State object, which stores a sequence of TimestampValuePair objects, that represent the 
history of that member on a particular instance of consensus.
The blockchain is updated whenever a consensus decision is reached, ensuring
that all non-faulty members have a consistent view of the blockchain.

A message handler loop continuously listens for incoming messages. If a
CLIENTREQUEST is received and the member is the leader, it initiates a new
consensus instance to process the request. For consensus-related messages, the
member delegates the message to the current consensus instance for processing.

%
\subsection{Consensus Layer}
The consensus mechanism in this project is designed to ensure that all
non-faulty members of the distributed system agree on the value to be appended
to the blockchain, even in the presence of Byzantine faults. The consensus
protocol is implemented in the ConsensusInstance class and involves multiple
phases.
\subsubsection{Consensus Instance}
Each consensus instancekeeps track of the current epoch number. 
The consensus instance is initiated by the leader
(process 1) when it receives a CLIENTREQUEST from a client. The leader is
responsible for coordinating the consensus process, while other members
participate by responding to messages and contributing their local states.
\subsubsection{Read Phase}
The consensus process begins with the read phase, where the leader broadcasts a
READ message to all members. Each member responds with a STATE message, which
contains its local blockchain state, including the most recent write and the
writeset (a list of all writes), both related to the current epoch.

\subsubsection{Collected Phase}
Once the leader has received STATE messages from a quorum of members, it
broadcasts a COLLECTED message to all members. The COLLECTED message contains
the collected states from the quorum's members, allowing each member to independently
determine the value to be written. Members use the collected states to select
the most recent value that appears in the writeset of more than f members (where
f is the maximum number of Byzantine faults tolerated). If no such value exists,
the value is unbounded. In this case, the leader's most recent write is selected 
as the candidate value.
\subsubsection{Write Phase}
Every process (members and leader), after determining the value to be written,
broadcasts a WRITE message to all members. Upon receiving a quorum of Write messages (2*F+1),
the leader broadcasts an ACCEPT message to all members, containing the value <HOW TO OBTAIN THE VALUE>.


\subsubsection{Accept Phase}
-SIMAO STOPPED HERE
Once the leader has received ACCEPT messages from a quorum of members, it
broadcasts a DECIDED message to all members. The DECIDED message contains the
final value that has been agreed upon by the consensus instance. Upon receiving
the DECIDED message, each member appends the agreed-upon value to its local
blockchain and updates its state accordingly.
\subsubsection{Fault Tolerance and Quorum}
The consensus protocol is designed to tolerate up to f Byzantine faults, where f
is the maximum number of faulty members allowed in the network. A quorum is
defined as the minimum number of members required to reach agreement, calculated
as floor((N + f) / 2), where N is the total number of members. The protocol
ensures that all non-faulty members agree on the same value, even if some
members behave maliciously or fail to respond.

%
\section{Implementation details}
\subsection{PKI and Cryptography}
The system relies on a Public Key Infrastructure (PKI) to ensure the identity of
members. Due to the perfomance limitations of public key cryptography, the
system derives a shared simmetric key for each session, which is used to sign
the messages. Since confidentiality is not a requirement, the system does not
encrypt the messages.
%
\subsection{Byzantine leader}
Due to the scope of the project, the system assumes a correct leader process
(process 1) that initiates consensus instances and coordinates the consensus
protocol. However, the system is designed to handle Byzantine behavior, and so,
if the leader behaves maliciously and deviates from the protocol, the other
members will detect the misbehavior and abort the consensus instance.
%
\subsection{Members replies}
Whenever a client issues a request, it will not block waiting for the reply,
since the consensus protocol may take some time to reach an agreement. Instead,
the client will asynchronously wait for the rely. As a client, it will wait for 
F+1 replies, where F is the number of Byzantine faults the system can tolerate.
%
\subsection{Client only communicates with the leader}
To simplify the system, the client only communicates with the leader process.
This design choice is based on the assumption that the leader is correct and
will not deviate from the protocol.
%
\section{Possible threats and corresponding protection mechanisms} To
demonstrate the system's resilience against various Byzantine scenarios, the
implementation was tested under multiple configurations, each representing a
different type of attack. The following sections provide a detailed explanation
of how each attack is executed and how the system effectively mitigates it.
\subsection{Correct Configuration}
In the correct configuration, all members behave honestly and follow the
protocol.
%
\subsection{Ignore Messages}
In this scenario, a faulty member ignores messages from the leader or other
members, with the goal of disrupting the consensus process. The system is
designed to handle this scenario by not needed to wait for all members to reply
(only 2F+1 replies are needed).
%
\subsection{Byzantine State}
In this scenario, a faulty member sends a STATE message containing an incorrect
blockchain state, with the goal of misleading the leader. The system is designed
to handle this scenario, <HOW>.
%
\subsection{Byzantine Decide}
In this scenario, a faulty member sends a DECIDED message containing an
incorrect value, with the goal of disrupting the consensus process. The system
is designed to handle this scenario, <HOW>.
%
\section{Conclusion}
The first stage of the DepChain project has been successfully completed,
resulting in a functional blockchain system that can tolerate Byzantine faults
and operate reliably in an unstable network environment. The system leverages
the Byzantine Read/Write Epoch Consensus algorithm to achieve consensus among
non-faulty members, ensuring that all members agree on the state of the
blockchain.

\begin{thebibliography}{8}

\bibitem{ref_book1}
Christian Cachin, Rachid Guerraoui, Luís Rodrigues: Introduction to Reliable and
Secure Distributed Programming. 2nd edn. Springer, 2011

\bibitem{ref_url1}
Java Crypto API,
\url{https://docs.oracle.com/javase/8/docs/api/javax/crypto/package-summary.html}

\bibitem{ref_url2}
Theoretical Classes Slides, HDS2425
\url{https://fenix.tecnico.ulisboa.pt/disciplinas/ SDTF236/2024-2025/2-semestre/theoretical-classes}
\end{thebibliography}
\end{document}
